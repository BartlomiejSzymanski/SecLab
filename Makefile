TOOLCHAIN := riscv64-unknown-elf
CC := $(TOOLCHAIN)-gcc
OBJCOPY := $(TOOLCHAIN)-objcopy
OBJDUMP := $(TOOLCHAIN)-objdump

# -m{arch,abi,tune} specify the arch/processor that is used
# -nostdlib means that we don't link to any stdlib
# -Os optimize for size (we only have 0x800 bytes)
# -Wno-builtin-declaration-mismatch fixes a warning abou the memcpy signature
# -f{function,data}-sections puts functions/data in their own sections (for garbage collection)
# -msmall-data-limit=0 turns of the sbss and sdata sections generated by gcc by default

CFLAGS := -march=rv32imac -mabi=ilp32 -mtune=sifive-3-series -nostdlib -Os -Wno-builtin-declaration-mismatch -ffunction-sections -fdata-sections -msmall-data-limit=0 -fno-builtin

# CFLAGS are included to reuse -m*, -nostdlib, etc. (CC is used for linking)
# -Tlinker.ld is the linker script
# --entry=_start --gc-sections make unused code disapear (garbage collection)
LDFLAGS := $(CFLAGS) -Tlinker.ld --entry=_start -Wl,--gc-sections
LDFLAGS_2 := $(CFLAGS) -Tlinker.ld --entry=_start -Wl,--gc-sections
all: main.raw game0.raw game1.raw game2.raw game3.raw

game0.raw: game0
	$(OBJCOPY) -O binary $< $@

game1.raw: game1
	$(OBJCOPY) -O binary $< $@

game2.raw: game2
	$(OBJCOPY) -O binary $< $@

game3.raw: game3
	$(OBJCOPY) -O binary $< $@

game0: game0.o syscalls.o helpers.o startup.o 
game1: game1.o syscalls.o helpers.o startup.o
game2: game2.o syscalls.o helpers.o startup.o
game3: game3.o syscalls.o helpers.o startup.o

clean:
	rm -f *.raw *.o game0 game1 game2 game3

dump-raw: game0.raw game1.raw game2.raw game3.raw
	$(OBJDUMP) -b binary -m riscv:rv32 -D game0.raw 
	$(OBJDUMP) -b binary -m riscv:rv32 -D game1.raw 
	$(OBJDUMP) -b binary -m riscv:rv32 -D game2.raw 
	$(OBJDUMP) -b binary -m riscv:rv32 -D game3.raw 
dump: game3
	$(OBJDUMP) -D $<

# dump: main
# 	$(OBJDUMP) -D $<
